{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#pixel-partitioner-tools-for-pixel-partitioning-intensity-based-segmentation-and-visualization","title":"Pixel Partitioner: Tools for pixel partitioning, intensity-based segmentation, and visualization.","text":"<p>Pixel Partitioner is a computational tool designed to facilitate the analysis of single-layer TIFF images by quantifying the presence of specific markers within these images. The primary objective of this package is to discern and quantify signal within images, returning the percentage of pixels that are positive for a designated marker.</p> <p>Input Specification: The package processes single-layer TIFF images, catering to the requirements of image analysis in fields such as cancer biology, where accurate identification of markers is crucial for understanding disease initiation and progression.</p> <p>Methodological Approach: Pixel Partitioner employs a multi-class Otsu thresholding method as its core algorithm. This technique is pivotal for its ability to differentiate between pixels positive for the marker of interest and the background. Initially, the package applies a two-class Otsu thresholding to segregate positive pixels. Recognizing the challenge of high background noise, which may result in overclassification, the package implements an innovative strategy to refine its analysis. It operates under the assumption that the expression of a given marker should not exceed a certain threshold - by default, set at 5% of the total pixels in any given image. If the percentage of positive pixels surpasses this threshold, indicating potential overclassification due to background noise, the software automatically escalates to a three-class Otsu thresholding. This process is iteratively conducted until the positive pixel percentage falls below the set threshold, ensuring robustness in signal identification.</p> <p>Adaptive Features: An essential aspect of Pixel Partitioner is its adaptability. It records detailed information regarding the thresholding process and the resultant pixel classification in a dataframe, which is subsequently saved as a CSV file in a user-specified output directory. Moreover, to enhance user confidence in the results, the package generates modified copies of the original images, overlaying the classified positive pixels. This visual output allows users to verify the accuracy of the segmentation. In instances where the output does not meet the user's expectations, options are available to adjust the <code>percentPositiveThreshold</code> parameter or exclude particularly challenging images from the dataset, thereby offering flexibility in handling diverse image sets.</p> <p>In summary, Pixel Partitioner stands as a tool that streamlines the quantification of specific markers in single-layer TIFF images through advanced thresholding techniques. Its capability to adaptively refine its approach based on the background noise and the specific requirements of the analysis makes it a valuable resource for scientists and researchers engaged in image analysis, particularly within the realms of cancer biology and other fields where precise marker quantification is imperative.</p>"},{"location":"install/","title":"\ud83d\udc0a Getting Started with Pixel Partitioner","text":"<p>Before we set up Pixel Partitioner, we highly recommend using a environment manager like Conda. Using an environment manager like Conda allows you to create and manage isolated environments with specific package versions and dependencies. </p> <p>Download and Install the right conda based on the opertating system that you are using</p>"},{"location":"install/#create-a-new-conda-environment","title":"Create a new conda environment","text":"<pre><code># use the terminal (mac/linux) and anaconda promt (windows) to run the following command\n\nconda create --name pixelpartitioner -y python=3.11\nconda activate pixelpartitioner\n</code></pre> <p>Install <code>pixelpartitioner</code> within the conda environment.</p> <pre><code>pip install pixelpartitioner\n</code></pre>"},{"location":"install/#use-ide-or-jupyter-notebook-to-run-the-package","title":"Use IDE or Jupyter notebook to run the package","text":"<pre><code>pip install notebook\n\n# open the notebook and import pixelpartitioner\nimport pixelpartitioner as pp\n\n# Go to the tutorial section to follow along\n</code></pre>"},{"location":"Functions/PixelPartitioner/","title":"PixelPartitioner","text":"<p>Short Description</p> <p>The <code>PixelPartitioner</code> function applies multi-class OTSU thresholding to a set of images  to partition pixels based on intensity. It iteratively increases the number of classes for  images with a high percentage of pixels exceeding a specified threshold, accumulating  results in a DataFrame. The final results are saved in a CSV file within the specified output folder.</p>"},{"location":"Functions/PixelPartitioner/#pixelpartitioner.PixelPartitioner--function","title":"Function","text":""},{"location":"Functions/PixelPartitioner/#pixelpartitioner.PixelPartitioner.PixelPartitioner","title":"<code>PixelPartitioner(imagePaths, outputFolder, num_classes=2, percentPositiveThreshold=5, verbose=True)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>imagePaths</code> <code>list of str</code> <p>A list of paths to images that will undergo pixel partitioning.</p> required <code>outputFolder</code> <code>str</code> <p>The directory where the output results, including a master DataFrame as a CSV file, will be saved. The function will create a 'results' subfolder in this directory for the CSV file.</p> required <code>num_classes</code> <code>int</code> <p>The initial number of classes to use for OTSU thresholding. Default is 2.</p> <code>2</code> <code>percentPositiveThreshold</code> <code>int or float</code> <p>The percentage threshold used to determine if an image has a greater percentage of pixels in the highest class than specified. Images exceeding this threshold will be re-processed in subsequent iterations with an increased number of classes. Default is 5.</p> <code>5</code> <code>verbose</code> <code>bool</code> <p>If True, the function will print verbose messages about its progress. Default is True.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>DataFrame</code> <code>DataFrame</code> <p>A DataFrame containing the cumulative results of the pixel partitioning process, with columns representing the results of different num_classes iterations.</p> Example <pre><code>imagePaths = ['/path/to/images/img1.tif', '/path/to/images/img2.tif']\noutputFolder = '/path/to/output'\nnum_classes = 2\npercentPositiveThreshold = 5\n\n# Execute pixel partitioning\nresults_df = pp.PixelPartitioner(imagePaths=imagePaths, \n                              outputFolder=outputFolder, \n                              num_classes=num_classes, \n                              percentPositiveThreshold=percentPositiveThreshold)\n</code></pre> Source code in <code>pixelpartitioner/PixelPartitioner.py</code> <pre><code>def PixelPartitioner (imagePaths, \n                      outputFolder, \n                      num_classes=2,\n                      percentPositiveThreshold=5,\n                      verbose=True):\n\n    \"\"\"\n\nParameters:\n        imagePaths (list of str): \n            A list of paths to images that will undergo pixel partitioning.\n        outputFolder (str): \n            The directory where the output results, including a master DataFrame as a CSV file, will be saved. The function will create a 'results' subfolder in this directory for the CSV file.\n        num_classes (int, optional): \n            The initial number of classes to use for OTSU thresholding. Default is 2.\n        percentPositiveThreshold (int or float, optional): \n            The percentage threshold used to determine if an image has a greater percentage of pixels in the highest class than specified. Images exceeding this threshold will be re-processed in subsequent iterations with an increased number of classes. Default is 5.\n        verbose (bool, optional): \n            If True, the function will print verbose messages about its progress. Default is True.\n\nReturns:\n        DataFrame (pandas.DataFrame): \n            A DataFrame containing the cumulative results of the pixel partitioning process, with columns representing the results of different num_classes iterations.\n\nExample:\n        ```python\n\n        imagePaths = ['/path/to/images/img1.tif', '/path/to/images/img2.tif']\n        outputFolder = '/path/to/output'\n        num_classes = 2\n        percentPositiveThreshold = 5\n\n        # Execute pixel partitioning\n        results_df = pp.PixelPartitioner(imagePaths=imagePaths, \n                                      outputFolder=outputFolder, \n                                      num_classes=num_classes, \n                                      percentPositiveThreshold=percentPositiveThreshold)\n        ```\n\n    \"\"\"\n\n\n    # loop through all TSU thresholds\n    paths_to_remaining_files = imagePaths[:]  # Copy of the initial list of image paths\n    master_df = pd.DataFrame()  # Initialize an empty DataFrame for accumulating results\n    first_num_classes = num_classes  # Store the initial num_classes value\n\n    # Loop until there are no remaining files to process\n    while len(paths_to_remaining_files) &gt; 0:\n\n        # Print statements for verbose output\n        if verbose: \n            print(f'Performing OTSU Thresholding with {num_classes} classes')\n\n        # Perform multi-class OTSU thresholding\n        df = process_images(image_paths=paths_to_remaining_files, outputFolder=outputFolder, num_classes=num_classes)\n\n        # Identify images that have a greater percentage of pixels than the user-specified threshold\n        column_name = f\"{num_classes}_class_OTSU\"  # Dynamic column name based on num_classes\n        failedSample = df[df[column_name] &gt; percentPositiveThreshold]['FileName'].tolist()\n\n        # Prepare the DataFrame for merging\n        df.set_index('FileName', inplace=True)\n\n        # Merge with the master DataFrame\n        if master_df.empty:\n            master_df = df[[column_name]].copy()\n        else:\n            # Ensuring all previous iterations are carried forward even if they're missing in the current df\n            master_df = master_df.join(df[[column_name]], how='outer')\n\n        # Update paths for the next iteration\n        if failedSample:\n            path_to_prepend = os.path.dirname(paths_to_remaining_files[0])\n            paths_to_remaining_files = [os.path.join(path_to_prepend, file_name) for file_name in failedSample]\n            num_classes += 1  # Increase the number of classes for the next iteration\n        else:\n            break  # Exit loop if no failed samples\n\n    # Sort the master DataFrame based on the first iteration results, from largest to smallest\n    first_iteration_column = f\"{first_num_classes}_class_OTSU\"\n    if not master_df.empty and first_iteration_column in master_df.columns:\n        master_df.sort_values(by=first_iteration_column, ascending=False, inplace=True)\n\n    # Save master_df that contains the cumulative results with num_classes iterations as columns\n    results_folder = os.path.join(outputFolder, 'results')\n    # Create the 'results' folder if it does not exist\n    if not os.path.exists(results_folder):\n        os.makedirs(results_folder)\n    # Specify the filename for saving the DataFrame\n    filename = 'master_results.csv'\n    # Construct the full path to the file\n    file_path = os.path.join(results_folder, filename)\n    # Save the master_df DataFrame to CSV in the 'results' folder\n    master_df.to_csv(file_path, index=True)\n    if verbose:\n        print(\"---------------------------------------------\")\n        print(f\"Master DataFrame saved to: {file_path}\")\n        print(f\"Thresholded Images saved to: {outputFolder}\")\n\n    # return data\n    return master_df\n</code></pre>"},{"location":"Functions/getImages/","title":"getImages","text":"<p>Short Description</p> <p>The <code>pp.getImages</code> function retrieves image file paths from a specified directory,  with an optional filter for file extensions. It simplifies collecting images for analysis,  allowing for specific format selection in folders with multiple elements. </p>"},{"location":"Functions/getImages/#pixelpartitioner.getImages--function","title":"Function","text":""},{"location":"Functions/getImages/#pixelpartitioner.getImages.getImages","title":"<code>getImages(folderPath, extension=None)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>folderPath</code> <code>str</code> <p>The path to the directory from which files will be listed. This directory should already exist and be accessible at the time of function invocation.</p> required <code>extension</code> <code>str</code> <p>The file extension used to filter the files listed by the function. If specified, the function will only return files that end with the given extension (e.g., 'tif' ). The extension should not include the leading period ('.'). If None or not provided, all files in the directory will be listed. Default is None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>list</code> <code>list</code> <p>A list containing the full paths to the files that meet the criteria. If an extension is specified, only files with that extension will be included in the list.</p> Example <pre><code># Listing all `tif` files in a directory called 'documents':\n\nimagePaths = pp.getImages(directory='/path/to/dir/documents', extension = 'tif')\n</code></pre> Source code in <code>pixelpartitioner/getImages.py</code> <pre><code>def getImages (folderPath, \n               extension=None):\n\n    \"\"\"\nParameters:\n    folderPath (str):\n        The path to the directory from which files will be listed. This directory should already exist and be accessible at the time of function invocation.\n\n    extension (str, optional):\n        The file extension used to filter the files listed by the function. If specified, the function will only return files that end with the given extension (e.g., 'tif' ). The extension should not include the leading period ('.'). If None or not provided, all files in the directory will be listed. Default is None.\n\nReturns:\n    list (list): \n        A list containing the full paths to the files that meet the criteria. If an extension is specified, only files with that extension will be included in the list.\n\n\nExample:\n    ```python\n\n    # Listing all `tif` files in a directory called 'documents':\n\n    imagePaths = pp.getImages(directory='/path/to/dir/documents', extension = 'tif')\n\n    ```\n\n\n\"\"\"\n\n    files = []  # List to store the paths of files\n    # Normalize the extension to ensure it starts with a dot\n    if extension and not extension.startswith('.'):\n        extension = '.' + extension\n\n    for file in os.listdir(folderPath):\n        file_path = os.path.join(folderPath, file)\n        # Check if it's a file and not a directory\n        if os.path.isfile(file_path):\n            # If extension is provided, filter files by the extension\n            if extension:\n                if file.endswith(extension):\n                    files.append(file_path)\n            else:\n                files.append(file_path)\n\n    return files\n</code></pre>"},{"location":"Functions/plotPixel/","title":"plotPixel","text":"<p>Short Description</p> <p>The <code>plotPixel</code> function visualizes the effect of multi-class OTSU thresholding on an image,  highlighting the positive regions determined by the threshold. he result is a side-by-side plot  of the original and highlighted images, with a quantitative display of the positive pixels'  percentage.</p>"},{"location":"Functions/plotPixel/#pixelpartitioner.plotPixel--function","title":"Function","text":""},{"location":"Functions/plotPixel/#pixelpartitioner.plotPixel.plotPixel","title":"<code>plotPixel(imagePath, num_classes=2)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>image_path</code> <code>str</code> <p>The path to the image file to be processed. Supports formats readable by tifffile, such as TIFF.</p> required <code>num_classes</code> <code>int</code> <p>The number of classes to divide the pixel intensity range into using OTSU thresholding. Default is 2.</p> <code>2</code> <p>Returns:</p> Name Type Description <code>Plot</code> <code>matplotlib</code> <p>Returns a plot comparing original image with the regions identified to be positive for signal.</p> Example <pre><code># Plot the results for image.tif\n\npp.plotPixel(image_path='/path/to/image.tif', num_classes=3)\n</code></pre> Source code in <code>pixelpartitioner/plotPixel.py</code> <pre><code>def plotPixel(imagePath, \n              num_classes=2):\n\n    \"\"\"\nParameters:\n        image_path (str): \n            The path to the image file to be processed. Supports formats readable by tifffile, such as TIFF.\n        num_classes (int, optional): \n            The number of classes to divide the pixel intensity range into using OTSU thresholding. Default is 2.\n\nReturns:\n        Plot (matplotlib): \n            Returns a plot comparing original image with the regions identified to be positive for signal.\n\n\nExample:\n    ```python\n\n    # Plot the results for image.tif\n\n    pp.plotPixel(image_path='/path/to/image.tif', num_classes=3)\n\n    ```\n\n    \"\"\"\n\n\n    # Load the image using tifffile\n    image = tifffile.imread(imagePath)\n\n    # Check if the image is RGB and convert to grayscale if necessary\n    if image.ndim == 3 and image.shape[2] == 3:\n        greyImage = rgb2gray(image)\n\n    # Normalize the image intensity to the range [0, 1]\n    normalized_image = exposure.rescale_intensity(greyImage.astype(np.float32), out_range=(0, 1))\n\n    # Apply multi-class Otsu thresholding with user-defined number of classes\n    thresholds = filters.threshold_multiotsu(normalized_image, classes=num_classes)\n    regions = np.digitize(normalized_image, bins=thresholds)\n\n    # Calculate the percentage of pixels in the brightest class\n    brightest_pixels = np.sum(regions == num_classes - 1)\n    total_pixels = np.prod(regions.shape)\n    percentage_brightest = (brightest_pixels / total_pixels) * 100\n\n    # Highlight regions in the brightest class\n    highlighted_image = gray2rgb(normalized_image) if normalized_image.ndim == 2 else normalized_image.copy()\n    highlighted_image[regions == num_classes - 1] = [1, 0, 0]  # Red for the brightest class\n\n    # Plotting\n    fig, ax = plt.subplots(1, 2, figsize=(12, 6))\n    ax[0].imshow(image, cmap='gray')\n    ax[0].set_title('Original Image')\n    ax[0].axis('off')\n\n    ax[1].imshow(highlighted_image)\n    ax[1].set_title('Highlighted Positive Regions')\n    ax[1].axis('off')\n\n    plt.figtext(0.5, 0.01, f'Percentage of Positive Pixels: {percentage_brightest:.2f}%', ha=\"center\", fontsize=12)\n    plt.tight_layout()\n</code></pre>"},{"location":"Tutorials/md/QuickStartGuide/","title":"\ud83c\udfaf Quick Start Guide","text":"<p>In this tutorial, we will guide you through the process of using the Pixel Partitioner package to identify and quantify the presence of specific markers in single-layer TIFF images. This package applies multi-class Otsu thresholding to distinguish positive pixels and allows for the adjustment of the classification threshold to suit your specific needs. Let's dive into the step-by-step guide on how to use Pixel Partitioner.</p> <pre><code># let's import the package\nimport pixelpartitioner as pp\n</code></pre>"},{"location":"Tutorials/md/QuickStartGuide/#step-1-find-the-image-files-to-process","title":"Step 1: Find the Image Files to Process","text":"<p>The first step involves identifying and gathering all the TIFF images you wish to analyze. This is achieved by specifying the folder path where your images are stored. Here is how you do it:</p> <pre><code># Change to the directory that contains YOUR data\nfolderPath = '/Users/aj/Dropbox (Partners HealthCare)/nirmal lab/softwares/pixelpartitioner/tests/data'\n</code></pre> <pre><code>imagePaths = pp.getImages(folderPath=folderPath, extension='tif')\n</code></pre> <p>In this code snippet, <code>getImages</code> is a function that scans the specified <code>folderPath</code> for all files with the '.tif' extension and returns a list of paths to these images. This list (<code>imagePaths</code>) will then be used as input for the Pixel Partitioner.</p>"},{"location":"Tutorials/md/QuickStartGuide/#step-2-applying-otsu-thresholding","title":"Step 2: Applying OTSU Thresholding","text":"<p>Once you have all the image paths, you can proceed to apply the OTSU thresholding algorithm to identify the positive pixels for the given marker. The Pixel Partitioner package automates this process and adjusts the classification based on the background noise, ensuring accurate segmentation.</p> <pre><code># Change for YOUR data\noutputFolder = '/Users/aj/Downloads/' # change to the location where you would like to save your results\npercentPositiveThreshold = 5 # this says that the positive pixels should not exceed 5% (adjust as needed according to the marker)\n</code></pre> <pre><code>results_df = pp.PixelPartitioner(imagePaths=imagePaths, \n                              outputFolder=outputFolder, \n                              percentPositiveThreshold=percentPositiveThreshold)\n</code></pre> <pre><code>Performing OTSU Thresholding with 2 classes\n---------------------------------------------\nMaster DataFrame saved to: /Users/aj/Downloads/results/master_results.csv\nThresholded Images saved to: /Users/aj/Downloads/\n</code></pre> <p>Here, <code>PixelPartitioner</code> is the core function of the package. It takes the list of image paths (<code>imagePaths</code>), the output folder path (<code>outputFolder</code>) where the results and modified images will be saved, and the <code>percentPositiveThreshold</code>. This threshold determines the sensitivity of the classification process, with the default set to 5%. The function returns a DataFrame (<code>results_df</code>) containing detailed information about the analysis, including the percentage of positive pixels identified in each image.</p> <p>Importantly, the images with the positive pixels identified and overlaid will be saved in the <code>outputFolder</code>. We highly encourage you to review these modified images to assess the performance of the method. Although it is not necessary to inspect every single image, examining a subset is crucial to ensure that the segmentation and classification have been conducted accurately. This visual inspection allows you to confirm the effectiveness of the Pixel Partitioner in identifying the marker of interest and provides an opportunity to adjust parameters or exclude challenging images from the analysis if necessary.</p>"},{"location":"Tutorials/md/QuickStartGuide/#step-3-helper-plotting-function","title":"Step 3: Helper Plotting Function","text":"<p>To visualize the percentage of positive pixels in a specific image, you can use the <code>plotPixel</code> function. This function generates a plot displaying the distribution of positive pixels across different classes, providing a visual insight into the classification results.</p> <pre><code># Change for YOUR data\nimagePath = '/Users/aj/Dropbox (Partners HealthCare)/nirmal lab/softwares/pixelpartitioner/tests/data/image_1.tif'\n</code></pre> <pre><code>pp.plotPixel(imagePath=imagePath, num_classes=2)\n</code></pre> <p></p> <p>In this example, <code>plotPixel</code> takes the path to a specific image (<code>imagePath</code>) and the number of classes (<code>num_classes</code>) as parameters. The <code>num_classes</code> parameter should match the classification used during the thresholding process. This will produce a plot for the specified image, allowing for a quick assessment of the segmentation quality.</p>"},{"location":"Tutorials/md/QuickStartGuide/#conclusion","title":"Conclusion","text":"<p>By following these steps, you can effectively use the Pixel Partitioner package to analyze single-layer TIFF images, identify positive pixels for specific markers, and quantify their presence with precision. The package's flexibility in adjusting the percent positive threshold and its ability to visually validate the results make it a valuable tool for researchers working with imaging datasets.</p> <p>Remember, the visual output and the generated CSV file provide comprehensive insights into the segmentation process, enabling you to fine-tune the analysis parameters or exclude challenging images to achieve the desired accuracy in marker quantification.</p>"}]}